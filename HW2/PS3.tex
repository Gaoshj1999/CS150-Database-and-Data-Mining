\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}
    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for grffile with XeLaTeX
    \def\Gread@@xetex#1{%
      \IfFileExists{"\Gin@base".bb}%
      {\Gread@eps{\Gin@base.bb}}%
      {\Gread@@xetex@aux#1}%
    }
    \makeatother

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{PS3}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        \ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{problem-set-3}{%
\section{Problem Set 3}\label{problem-set-3}}

\hypertarget{instructions-notes}{%
\subsubsection{Instructions / Notes:}\label{instructions-notes}}

\textbf{\emph{Read these carefully}}

\begin{itemize}
\tightlist
\item
  \textbf{Please read all the points of the ``Notes'' sections- they're
  important for this PS!!!}
\item
  You \textbf{are not required to do any plotting in this PS- only in
  certain problems to provide the tuples that would generate a plot.}
  You can then optionally plot (in the notebook with matplotlib, in
  Excel, wherever works)
\item
  You \textbf{may} create new IPython notebook cells to use for
  e.g.~testing, debugging, exploring, etc.- this is encouraged in fact!-
  \textbf{just make sure that your final answer for each question is
  \emph{in its own cell} and \emph{clearly indicated}}
\item
  \textbf{See Piazza for submission instructions}
\item
  \emph{Have fun!}
\end{itemize}

    \hypertarget{problem-1-double-trouble}{%
\subsection{Problem 1: Double Trouble}\label{problem-1-double-trouble}}

\textbf{\emph{{[}25 points total{]}}}

In this problem we'll explore an optimization often referred to as
\textbf{\emph{double buffering}}, which we'll use to speed up the
\textbf{external merge sort algorithm} we saw in \emph{Lecture 12}.

Although we haven't explicitly modeled it in many of our calculations so
far, recall that \emph{sequential IO} (i.e.~involving reading from /
writing to consecutive pages) is generally much faster that \emph{random
access IO} (any reading / writing that is not sequential). Additionally,
on newer memory technologies like SSD reading data can be faster than
writing data (if you want to read more about SSD access patterns look
\href{http://codecapsule.com/2014/02/12/coding-for-ssds-part-5-access-patterns-and-system-optimizations/}{here}.

In other words, for example, if we read 8 consecutive pages from file
\(A\), this should be much faster than reading 1 page from \(A\), then 1
page from file \(B\), then the next page from \(A\).

\textbf{In this problem, we will begin to model this, by assuming that 8
sequential \emph{READS} are ``free'', i.e.~the total cost of \(8\)
sequential reads is \(1\) IO. We will also assume that the writes are
always twice as expensive as a read. Sequential writes are never free,
therefore the cost of \(N\) writes is always \(2N\).}

\hypertarget{other-important-notes}{%
\subsubsection{Other important notes:}\label{other-important-notes}}

\begin{itemize}
\tightlist
\item
  \textbf{NO REPACKING:} Consider the external merge sort algorithm
  using the basic optimizations we present in section 1 of Lecture 12,
  but do not use the repacking optimization covered in Lecture 12.
\item
  \textbf{ONE BUFFER PAGE RESERVED FOR OUTPUT:} Assume we use one page
  for output in a merge, e.g.~a \(B\)-way merge would require \(B+1\)
  buffer pages
\item
  \textbf{REMEMBER TO ROUND:} Take ceilings (i.e.~rounding up to nearest
  integer values) into account in this problem for full credit! Note
  that we have sometimes omitted these (for simplicity) in lecture.
\item
  \textbf{Consider worst case cost:} In other words, if 2 reads
  \emph{could happen} to be sequential, but in general might not be,
  consider these random IO
\end{itemize}

    \hypertarget{part-a}{%
\subsubsection{Part (a)}\label{part-a}}

\textbf{\emph{{[}15 points{]}}}

Consider a modification of the external merge sort algorithm where
\textbf{reads are always read in 8-page chunks (i.e.~8 pages
sequentially at a time)} so as to take advantage of sequential reads.
Calculate the cost of performing the external merge sort for a setup
having \(B+1=40\) buffer pages and an unsorted input file with \(320\)
pages.

Show the steps of your work and make sure to explain your reasoning by
writing them as python comments above the final answers.

\hypertarget{part-a.i}{%
\paragraph{Part (a.i)}\label{part-a.i}}

What is the \textbf{exact} IO cost of spliting and sorting the files? As
is standard we want runs of size \(B+1\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{io\PYZus{}split\PYZus{}sort} \PY{o}{=}\PY{l+m+mi}{680}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-a.ii}{%
\paragraph{Part (a.ii)}\label{part-a.ii}}

After the file is split and sorted, we can merge \(n\) runs into 1 using
the merge process. What is largest \(n\) we could have, given reads are
always read in 8-page chunks? Note: this is known as the arity of the
merge.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{merge\PYZus{}arity} \PY{o}{=}\PY{l+m+mi}{32}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]

          File "<ipython-input-2-07e4a4225f29>", line 1
        merge\_arity =
                     \^{}
    SyntaxError: invalid syntax
    

    \end{Verbatim}

    \hypertarget{part-a.iii}{%
\paragraph{Part (a.iii)}\label{part-a.iii}}

How many passes of merging are required?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{merge\PYZus{}passes} \PY{o}{=} \PY{l+m+mi}{1}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-a.iv}{%
\paragraph{Part (a.iv)}\label{part-a.iv}}

What is the IO cost of the first pass of merging? Note: the highest
arity merge should always be used.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{merge\PYZus{}pass\PYZus{}1} \PY{o}{=} \PY{l+m+mi}{960}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-a.v}{%
\paragraph{Part (a.v)}\label{part-a.v}}

What is the total IO cost of running this external merge sort algorithm?
\textbf{Do not forget to add in the remaining passes (if any) of
merging.}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{total\PYZus{}io} \PY{o}{=}\PY{l+m+mi}{1640}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b}{%
\subsubsection{Part (b)}\label{part-b}}

\textbf{\emph{{[}5 points{]}}}

Now, we'll generalize the reasoning above by writing a python function
that computes the \emph{approximate}* cost of performing this version of
external merge sort for a setup having \(B+1\) buffer pages, a file with
\(N\) pages, and where we now read in \(P\)-page chunks (replacing our
fixed 8 page chunks in Part (a)).

**Note: our approximation will be a small one- for simplicity, we'll
assume that each pass of the merge phase has the same IO cost, when
actually it can vary slightly\ldots{} Everything else will be exact
given our model!*

We'll call this function \texttt{external\_merge\_sort\_cost(B,N,P)},
and we'll compute it as the product of the cost of reading in and
writing out all the data (which we do each pass), and the number of
passes we'll have to do.

Even though this is an approximation, \textbf{make sure to take care of
floor / ceiling operations- i.e.~rounding down / up to integer values
properly!}

\textbf{Importantly, to simplify your calculations: Your function will
only be evaluated on cases where the following hold:} * \textbf{(B + 1)
\% P == 0} (i.e.~the buffer size is divisible by the chunk size) *
\textbf{N \% (B + 1) == 0} (i.e.~the file size is divisible by the
buffer size)

    \hypertarget{part-b.i}{%
\paragraph{Part (b.i)}\label{part-b.i}}

First, let's write a python function that computes the \textbf{exact}
total IO cost to create the initial runs:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{cost\PYZus{}initial\PYZus{}runs}\PY{p}{(}\PY{n}{B}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{P}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{return} \PY{n}{N}\PY{o}{/}\PY{n}{P}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{N}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b.ii}{%
\paragraph{Part (b.ii)}\label{part-b.ii}}

Next, let's write a python function that computes the
\emph{approximate}* total IO cost to read in and then write out all the
data during one pass of the merge:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{cost\PYZus{}per\PYZus{}pass}\PY{p}{(}\PY{n}{B}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{P}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{return} \PY{l+m+mi}{3}\PY{o}{*}\PY{n}{N}
\end{Verbatim}
\end{tcolorbox}

    **Note that this is an approximation: when we read in chunks during the
merge phase, the cost per pass actually varies slightly due to `rounding
issues' when the file is split up into runs\ldots{} but this is a small
difference*

    \hypertarget{part-b.iii}{%
\paragraph{Part (b.iii)}\label{part-b.iii}}

Next, let's write a python function that computes the \textbf{exact}
total number of passes we'll need to do

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{num\PYZus{}passes}\PY{p}{(}\PY{n}{B}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{P}\PY{p}{)}\PY{p}{:}
    \PY{n}{truepass}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{n}{actuse}\PY{o}{=}\PY{n}{B}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{P}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{while} \PY{n}{N}\PY{o}{\PYZgt{}}\PY{n}{actuse}\PY{p}{:}
        \PY{n}{truepass}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
        \PY{n}{N}\PY{o}{=}\PY{n}{N}\PY{o}{/}\PY{n}{actuse}
    \PY{k}{return} \PY{n}{truepass}
\end{Verbatim}
\end{tcolorbox}

    Finally, our total cost function is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{external\PYZus{}merge\PYZus{}sort\PYZus{}cost}\PY{p}{(}\PY{n}{B}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{P}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{cost\PYZus{}initial\PYZus{}runs}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{n}{N}\PY{p}{,}\PY{n}{P}\PY{p}{)} \PY{o}{+} \PY{n}{cost\PYZus{}per\PYZus{}pass}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{n}{N}\PY{p}{,}\PY{n}{P}\PY{p}{)}\PY{o}{*}\PY{n}{num\PYZus{}passes}\PY{p}{(}\PY{n}{B}\PY{p}{,}\PY{n}{N}\PY{p}{,}\PY{n}{P}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-c}{%
\subsubsection{Part (c)}\label{part-c}}

\textbf{\emph{{[}10 points{]}}}

For \(B + 1 =100\) and \(N=900\), find the optimal \(P\) according to
your IO cost equation above. Return both the optimal \(P\) value
(\texttt{P\_opt}) and the list of tuples \textbf{\emph{for feasible
values of \(P\)}} that would generate a plot of P vs.~IO cost, at
resolution \(=1\)(every value of P), stored as \texttt{points}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Save the optimal value here}
\PY{n}{P} \PY{o}{=}\PY{l+m+mi}{50}
\PY{c+c1}{\PYZsh{} Save a list of tuples of (P, io\PYZus{}cost) here, for all feasible P\PYZsq{}s}
\PY{n}{points} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{l+m+mi}{100}\PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{==}\PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{points}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{external\PYZus{}merge\PYZus{}sort\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{99}\PY{p}{,}\PY{l+m+mi}{900}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    *Below we provide starter code for using \texttt{matplotlib} in the
notebook, if you want to generate the graph of P vs.~IO cost; however
any other software that allows you to visualize the plot (Excel, Google
spreadsheets, MATLAB, etc) is fine!

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Shell code for plotting in matplotlib}
\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Plot}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{o}{*}\PY{n+nb}{zip}\PY{p}{(}\PY{o}{*}\PY{n}{points}\PY{p}{)}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{problem-2-io-cost-models}{%
\subsection{Problem 2: IO Cost Models}\label{problem-2-io-cost-models}}

\textbf{\emph{{[}15 points total{]}}}

    In this problem we consider different join algorithms when joining
relations \(R(A,B)\),\(S(B,C)\), and \(T(C,D)\). We want to investigate
the cost of various pairwise join plans and try to determine the best
join strategy given some conditions.

Specifically, for each part of this question, we are intereseted
determining some (or all) of the following variables:

\begin{itemize}
\tightlist
\item
  \texttt{P\_R}: Number of pages of \(R\)
\item
  \texttt{P\_S}: Number of pages of \(S\)
\item
  \texttt{P\_RS}: Number of pages of output (and input) \(RS\)
\item
  \texttt{P\_T}: Number of pages of \(T\)
\item
  \texttt{P\_RST}: Number of pages of output (and input) \(RS\)
\item
  \texttt{B}: Number of pages in buffer
\item
  \texttt{IO\_cost\_join1}: Total IO cost of first join
\item
  \texttt{IO\_cost\_join2}: Total IO cost of second join
\end{itemize}

\hypertarget{note}{%
\paragraph{Note:}\label{note}}

\begin{itemize}
\tightlist
\item
  ** The output of join1 is always feed as one of the inputs to join 2
  **
\item
  \textbf{Use the ``vanilla'' versions of the algorithms as presented in
  lecture, \emph{i.e.~without any of the optimizations we mentioned}}
\item
  \textbf{Again assume we use one page for output, as in lecture!}
\item
  ** The abbreviates for the joins used are Sort-Merge Join (SMJ), Hash
  Join (HJ), and Block Nested Loop Join (BNLJ). **
\end{itemize}

    \hypertarget{part-a}{%
\subsubsection{Part (a)}\label{part-a}}

\textbf{\emph{{[}8 points{]}}}

Given: * \texttt{P\_R}: 20 * \texttt{P\_S}: 200 * \texttt{P\_T}: 2000 *
\texttt{P\_RS}: 100 * \texttt{P\_ST}: 1000 * \texttt{P\_RST}: 500 *
\texttt{B}: 32

Compute the IO cost for the following query plans:

\begin{itemize}
\tightlist
\item
  IO\_Cost\_HJ\_1 where only hash join is used,
  \(join1 = R(a,b),S(b,c)\) and \(join2 = join1(a,b,c),T(c,d)\)
\item
  IO\_Cost\_HJ\_2 where only hash join is used,
  \(join1 = T(c,d),S(b,c)\) and \(join2 = join1(b,c,d),R(a,b)\)
\item
  IO\_Cost\_SMJ\_1 where only sort merge join is used,
  \(join1 = R(a,b),S(b,c)\) and \(join2 = join1(a,b,c),T(c,d)\)
\item
  IO\_Cost\_SMJ\_2 where only sort merge join is used,
  \(join1 = T(c,d),S(b,c)\) and \(join2 = join1(b,c,d),R(a,b)\)
\item
  IO\_Cost\_BNLJ\_1 where only block nested loop join is used,
  \(join1 = R(a,b),S(b,c)\) and \(join2 = join1(a,b,c),T(c,d)\)
\item
  IO\_Cost\_BNLJ\_2 where only block nested loop merge join is used,
  \(join1 = T(c,d),S(b,c)\) and \(join2 = join1(b,c,d),R(a,b)\)
\end{itemize}

\textbf{Note: again, be careful of rounding for this problem. Use
ceiling/floors whenever it is necessary.}

Include 1-2 sentences (as a python comment) above each answer explaining
the performance for each algorithm/query plan.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{IO\PYZus{}Cost\PYZus{}HJ\PYZus{}1} \PY{o}{=}\PY{l+m+mi}{6960}
\PY{c+c1}{\PYZsh{}join1=3*(20+200)=660(since 20\PYZlt{}31*31);join2=3*(100+2000)(since 100\PYZlt{}31*31)=6300+660=6960}
\PY{n}{IO\PYZus{}Cost\PYZus{}HJ\PYZus{}2} \PY{o}{=} \PY{l+m+mi}{9620}
\PY{c+c1}{\PYZsh{}join1:3*(200+2000)=6600;join2=3*(20+1000)=3020+6600=9620}
\PY{n}{IO\PYZus{}Cost\PYZus{}SMJ\PYZus{}1} \PY{o}{=} \PY{l+m+mi}{7960}
\PY{c+c1}{\PYZsh{}join1=3*(20+200)=660;join2=100*2+2000*(log31(2000/32)+1)+100+1000=7300+660=7960}
\PY{n}{IO\PYZus{}Cost\PYZus{}SMJ\PYZus{}2} \PY{o}{=}\PY{l+m+mi}{12860}
\PY{c+c1}{\PYZsh{}join1=200*2+2000*3+200+2000=8600;join2=20*2+1000*3+20+1000=4060+8600=12860}
\PY{n}{IO\PYZus{}Cost\PYZus{}BNLJ\PYZus{}1} \PY{o}{=} \PY{l+m+mi}{8320}
\PY{c+c1}{\PYZsh{}join1=20+(20/30)*200=220;join2=100+(100/30)*2000=8100+220=8320}
\PY{n}{IO\PYZus{}Cost\PYZus{}BNLJ\PYZus{}2} \PY{o}{=} \PY{l+m+mi}{9220}
\PY{c+c1}{\PYZsh{}join1=200+(200/30)*2000=8200;join2=20+(20/30)*1000=1020+8200=9220}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b}{%
\subsubsection{Part (b)}\label{part-b}}

For the query plan where \(join1 = R(a,b),S(b,c)\) and
\(join2 = join1(a,b,c),T(c,d)\) find a configuration where using HJ for
\(join1\) and SMJ for \(join2\) is cheaper than SMJ for \(join1\) and HJ
for \(join2\). The output sizes you choose for P\_RS and P\_RS must be
non-zero and feasible (e.g.~the maximum output size of \(join1\) is
P\_R*P\_S).

\textbf{\emph{{[}8 points{]}}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{P\PYZus{}R} \PY{o}{=} \PY{l+m+mi}{1000}
\PY{n}{P\PYZus{}S} \PY{o}{=} \PY{l+m+mi}{200}
\PY{n}{P\PYZus{}T} \PY{o}{=} \PY{l+m+mi}{100}
\PY{n}{P\PYZus{}RS} \PY{o}{=} \PY{l+m+mi}{100}
\PY{n}{P\PYZus{}RST} \PY{o}{=} \PY{l+m+mi}{500}
\PY{n}{B} \PY{o}{=} \PY{l+m+mi}{32}

\PY{n}{HJ\PYZus{}IO\PYZus{}Cost\PYZus{}join1} \PY{o}{=} \PY{l+m+mi}{3600}
\PY{n}{SMJ\PYZus{}IO\PYZus{}Cost\PYZus{}join2} \PY{o}{=}\PY{l+m+mi}{600}
\PY{c+c1}{\PYZsh{}join1=3*(1000+200)=3600since 200\PYZlt{}31*31);join2=3*(100+100)=600}
\PY{n}{SMJ\PYZus{}IO\PYZus{}Cost\PYZus{}join1} \PY{o}{=} \PY{l+m+mi}{4600}
\PY{n}{HJ\PYZus{}IO\PYZus{}Cost\PYZus{}join2} \PY{o}{=}\PY{l+m+mi}{600}
\PY{c+c1}{\PYZsh{}join1=2*200+3*1000+200+1000=4600;join2=3*(100+100)=600}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{problem-3-sequential-flooding}{%
\subsection{Problem 3: Sequential
Flooding}\label{problem-3-sequential-flooding}}

\textbf{\emph{{[}10 points total{]}}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{lru\PYZus{}cost}\PY{p}{(}\PY{n}{N}\PY{p}{,} \PY{n}{M}\PY{p}{,} \PY{n}{B}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{if} \PY{n}{N}\PY{o}{\PYZlt{}}\PY{o}{=}\PY{n}{B}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{return} \PY{n}{N}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{n}{M}\PY{o}{*}\PY{n}{N}
\end{Verbatim}
\end{tcolorbox}

    \textbf{Note: Before doing this question, it is highly recommended that
you go through \href{./Activity-15.ipynb}{Activity 15}, which covers
eviction policies for buffer managers such as LRU, and why
\emph{sequential flooding} can sometimes occurs with LRU.}

In the activity accompanying Lecture 15, we saw something called
\emph{sequential flooding} that can occur when a default eviction policy
(for example LRU) is used by the buffer manager. We saw that we can
achieve much lower IO cost by using a different eviction policy, MRU
(``most recently used'').

\textbf{Note that ``Most recently used'' means most recently accessed,
either from buffer or disk, consistent with what we showed in
Activity-15.}

For this problem, we will take a closer look at the IO cost of different
eviction policies when reading the pages of a file sequentially multiple
times.

\hypertarget{part-a}{%
\subsection{Part (a)}\label{part-a}}

\hypertarget{part-a.i}{%
\subsubsection{Part (a.i)}\label{part-a.i}}

\textbf{\emph{{[}1 point{]}}}

Write a python function \texttt{lru\_cost(N,M,B)} that computes the IO
cost of the LRU eviction policy when reading in all the papges of an
\(N\)-page file sequentially, \(M\) times, using a bugger with \(B+1\)
pages. Assume that after reading the files, you don't need to write them
out (you can just release them, so there is no write IO cost).

    \hypertarget{part-a.ii}{%
\subsubsection{Part (a.ii)}\label{part-a.ii}}

\textbf{\emph{{[}2 points{]}}}

Write a python function \texttt{mru\_cost(N,M,B)} that computes the IO
cost of the MRU eviction policy when reading in all the papges of an
\(N\)-page file sequentially, \(M\) times, using a bugger with \(B+1\)
pages. Assume that after reading the files, you don't need to write them
out (you can just release them, so there is no write IO cost).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mru\PYZus{}cost}\PY{p}{(}\PY{n}{N}\PY{p}{,} \PY{n}{M}\PY{p}{,} \PY{n}{B}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{if} \PY{n}{N}\PY{o}{\PYZlt{}}\PY{o}{=}\PY{n}{B}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{return} \PY{n}{N}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{n}{B}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{+}\PY{n}{M}\PY{o}{*}\PY{p}{(}\PY{n}{N}\PY{o}{\PYZhy{}}\PY{n}{B}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{mru\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
9
    \end{Verbatim}

    \hypertarget{part-a.iii}{%
\subsubsection{Part (a.iii)}\label{part-a.iii}}

\textbf{\emph{{[}2 points{]}}}

Now that you have written these functions, provide the tuples which
generate the plot of \textbf{M vs.~the absolute value of the difference
between LRU and MRU in terms of IO cost} for \(B=4\), \(N=7\), and \(M\)
between 1 and 20 inclusive (saved as the variable
\texttt{p3\_lru\_points})

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{B} \PY{o}{=} \PY{l+m+mi}{4}
\PY{n}{N} \PY{o}{=} \PY{l+m+mi}{7}
\PY{n}{M} \PY{o}{=} \PY{l+m+mi}{20} 
\PY{c+c1}{\PYZsh{} Provide a list of tuple (m, difference between LRU and MRU in terms of IO cost) here:}
\PY{n}{p3\PYZus{}lru\PYZus{}points} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{:}
    \PY{n}{lrucost}\PY{o}{=}\PY{n}{lru\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
    \PY{n}{mrucost}\PY{o}{=}\PY{n}{mru\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
    \PY{k}{if} \PY{n}{lrucost}\PY{o}{\PYZgt{}}\PY{o}{=}\PY{n}{mrucost}\PY{p}{:}
         \PY{n}{p3\PYZus{}lru\PYZus{}points}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{lrucost}\PY{o}{\PYZhy{}}\PY{n}{mrucost}\PY{p}{)}\PY{p}{)} 
    \PY{k}{else}\PY{p}{:}
         \PY{n}{p3\PYZus{}lru\PYZus{}points}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{mrucost}\PY{o}{\PYZhy{}}\PY{n}{lrucost}\PY{p}{)}\PY{p}{)}  
\end{Verbatim}
\end{tcolorbox}

    Again, you can optionally plot your answer to check that it seems
reasonable- starter code for doing this in the notebook below:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Shell code for plotting in matplotlib}
\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Plot}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{o}{*}\PY{n+nb}{zip}\PY{p}{(}\PY{o}{*}\PY{n}{p3\PYZus{}lru\PYZus{}points}\PY{p}{)}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_40_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{part-b}{%
\subsection{Part (b)}\label{part-b}}

Recall that the LRU eviction policy removes the least recently used page
when the buffer is full and a new page is referenced which is not there
in buffer. The basic idea behind LRU is that you timestamp your buffer
elements, and use the timestamps to decide when to evict elements. Doing
so efficiently, requires some serious book-keeping, this is why in
practice many buffer managers try to approximate LRU with other eviction
policies that are easier to implement.

Here we will focus on the \emph{CLOCK} or \emph{Second Chance} policy.
In the CLOCK eviction policy, the candidate pages for removal are
considered left-to-right in a circular manner(with wraparound), and a
page that has been accessed between consecutive considerations will not
be replaced. The page replaced is the one that - considered in a
circular manner - has not been accessed since its last consideration.

In more details the CLOCK policy proceeds maintains a circular list of
pages in the buffer and uses an additional \emph{clock (or second
chance) bit} for each page to track how often a page is accessed. The
bit is set to 1 whenever a page is referenced. When clock needs to read
in a new page in the buffer, it sweeps over existing pages in the buffer
looking for one with second chance bit set to 0. It basically replaces
pages that have not been referenced for one complete revolution of the
clock.

A high-level implementation of clock: 1. Associate a ``second chance''
bit with each page in the buffer. Initialize all bits to ZERO (0). 2.
Each time a page is referenced in the buffer, set the ``second chance''
bit to ONE (1). this will give the page a second chance\ldots{} 3. A new
page read into a buffer page has the second chance bit set to ZERO (0).
4. When you need to find a page for removal, look in left-to-right in a
circular manner(with wraparound) in the buffer pages: - If the second
chance bit is ONE, reset its second chance bit (to ZERO) and continue. -
If the second chance bit is ZERO, replace the page in the buffer.

You can find more details on CLOCK
\href{http://cseweb.ucsd.edu/classes/wi08/cse221-a/papers/carr81.pdf}{here}.

\hypertarget{part-b.i}{%
\subsubsection{Part (b.i)}\label{part-b.i}}

\textbf{\emph{{[}4 points{]}}}

Write a python function \texttt{clock\_cost(N,M,B)} that computes the IO
cost of the CLOCK eviction policy when reading in all the papges of an
\(N\)-page file sequentially, \(M\) times, using a bugger with \(B+1\)
pages. Assume that after reading the files, you don't need to write them
out (you can just release them, so there is no write IO cost).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{clock\PYZus{}cost}\PY{p}{(}\PY{n}{N}\PY{p}{,} \PY{n}{M}\PY{p}{,} \PY{n}{B}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} YOUR CODE HERE}
    \PY{k}{if} \PY{n}{N}\PY{o}{\PYZlt{}}\PY{o}{=}\PY{n}{B}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{return} \PY{n}{N}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{n}{M}\PY{o}{*}\PY{n}{N}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b.ii}{%
\subsubsection{Part (b.ii)}\label{part-b.ii}}

\textbf{\emph{{[}1 point{]}}}

Now that you have written the CLOCK cost function, provide the tuples
which generate the plot of \textbf{M vs.~the absolute value of the
difference between LRU and CLOCK in terms of IO cost} for \(B=4\),
\(N=7\), and \(M\) between 1 and 20 inclusive (saved as the variable
\texttt{p3\_clock\_points}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{B} \PY{o}{=} \PY{l+m+mi}{4}
\PY{n}{N} \PY{o}{=} \PY{l+m+mi}{7}
\PY{n}{M} \PY{o}{=} \PY{l+m+mi}{20}
\PY{n}{p3\PYZus{}clock\PYZus{}points} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{:}
    \PY{n}{lrucost}\PY{o}{=}\PY{n}{lru\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
    \PY{n}{clockcost}\PY{o}{=}\PY{n}{clock\PYZus{}cost}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}
    \PY{k}{if} \PY{n}{lrucost}\PY{o}{\PYZgt{}}\PY{o}{=}\PY{n}{clockcost}\PY{p}{:}
         \PY{n}{p3\PYZus{}clock\PYZus{}points}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{lrucost}\PY{o}{\PYZhy{}}\PY{n}{clockcost}\PY{p}{)}\PY{p}{)} 
    \PY{k}{else}\PY{p}{:}
         \PY{n}{p3\PYZus{}clock\PYZus{}points}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{clockcost}\PY{o}{\PYZhy{}}\PY{n}{lrucost}\PY{p}{)}\PY{p}{)}  
\end{Verbatim}
\end{tcolorbox}

    Does the CLOCK eviction policy prevent sequential flooding? How does it
perform against LRU? Write a short explanation in the field below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} EXPLANATION GOES HERE}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{problem-4-hash-join-madden}{%
\subsection{Problem 4: Hash Join
Madden}\label{problem-4-hash-join-madden}}

\textbf{\emph{{[}10 points total{]}}}

    The NFL season has started strong and Jack Del Rio
(\href{https://www.youtube.com/watch?v=YXj7I1RzLSE}{The Oakland
Raider's} coach) wants to find out if Joe Flacco is an elite
quarterback. He wants to do this by being more of a sabermetrics guy
than a numbers guy. As a first step in doing this he wants to find out
which are the colleges each NFL teams prefers drafting players from. We
have access to two tables: (i) a table named ``teams'' which contains
(team, player) pairs, and (ii) a table named ``colleges'' which contains
(player, college) pairs. Being all excited about databases you decide
that there is no other way but to join the two tables and get the
desired results. However, you have no access to a database. Not even a
challenge for you who decide to implement your favorite join algorithm
on your own. And of course HASH JOIN is the way to go!!!

    \hypertarget{load-and-explore-the-data}{%
\subsection{Load and explore the data}\label{load-and-explore-the-data}}

The two tables are stored in files which can be loaded into memory as
two lists of \textbf{named tuples} using the code below:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Load data}
\PY{k+kn}{import} \PY{n+nn}{nfl}
\PY{k+kn}{from} \PY{n+nn}{nfl} \PY{k+kn}{import} \PY{o}{*}
\PY{n}{teams}\PY{p}{,} \PY{n}{colleges} \PY{o}{=} \PY{n}{loadData}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Named tuples are basically lightweight object types and instances of
named tuple instances can be referenced using object like variable
deferencing or the standard tuple syntax. The following code prints the
first 10 tuples from teams and colleges. \emph{Notice how fields of
named tuples are accessed inside the loops.}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Print List Entries}
\PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Table teams contains }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{ entries in total}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{teams}\PY{p}{)}
\PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Table colleges contains }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{ entries in total}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n+nb}{len}\PY{p}{(}\PY{n}{colleges}\PY{p}{)}
\PY{n+nb}{print} 
\PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{First 10 entries in teams table}\PY{l+s+s1}{\PYZsq{}}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
    \PY{n}{team} \PY{o}{=} \PY{n}{teams}\PY{p}{[}\PY{n}{i}\PY{p}{]}
    \PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Entry }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{n}{team}\PY{o}{.}\PY{n}{teamname}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{|}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{team}\PY{o}{.}\PY{n}{playername}
\PY{n+nb}{print} 
\PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{First 10 entries in college table}\PY{l+s+s1}{\PYZsq{}}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
    \PY{n}{college} \PY{o}{=} \PY{n}{colleges}\PY{p}{[}\PY{n}{i}\PY{p}{]}
    \PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Entry }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{n}{college}\PY{o}{.}\PY{n}{collegename}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{|}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{college}\PY{o}{.}\PY{n}{playername}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{down-to-business}{%
\subsection{Down to business}\label{down-to-business}}

During the lectures we saw that hash joins consist of two phases: The
\textbf{Partition Phase} where using a hash function \(h\) we split the
two tables we want to join into \(B\) buckets, and the \textbf{Matching
Phase} where we iterate over each bucket and join the tuples from the
two tables that match. Here you will need to implement a hash join in
memory.

You are determined to implement the most efficient hash join possible!
This is why you decide to implement your own hash function that will
uniformly partition the entries of a table across \(B\) buckets so that
all buckets have roughly the same number of entries. You decide to use
the following hash function:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Define hash function}
\PY{k}{def} \PY{n+nf}{h}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}\PY{p}{:}
    \PY{n}{rawKey} \PY{o}{=} \PY{n+nb}{ord}\PY{p}{(}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{k}{return} \PY{n}{rawKey} \PY{o}{\PYZpc{}} \PY{n}{buckets}
\end{Verbatim}
\end{tcolorbox}

    You use this hash function to partition the tables. To do so you can use
the helper method \texttt{partitionTable(table,hashfunction,buckets)}
for convenience as shown next:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Fix the number of buckets to 500}
\PY{n}{buckets} \PY{o}{=} \PY{l+m+mi}{500}
\PY{c+c1}{\PYZsh{} Partition the teams table using hash function h}
\PY{n}{teamsPartition} \PY{o}{=} \PY{n}{partitionTable}\PY{p}{(}\PY{n}{teams}\PY{p}{,}\PY{n}{h}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    The output of \texttt{partitionTable()} is a dictionary with its keys
corresponding to bucket numbers in \([0,B-1]\) and its entries to lists
of named tuples.

\hypertarget{part-a}{%
\subsection{Part (a)}\label{part-a}}

\hypertarget{part-a.i}{%
\subsubsection{Part (a.i)}\label{part-a.i}}

\textbf{\emph{{[}4 points{]}}}

It's now time to implement your own hash join! You only need to
implement the merge phase of the hash join. The output of the method
should correspond to the result of a join between teams and colleges
over the \textbf{\emph{playername}} attribute. The partition phase is
implemented. You need to fill in the merge phase.

\textbf{\emph{Note: You should only use the two dictionaries t1Partition
and t1Partition provide. No other data structures are allowed.}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{hashJoin}\PY{p}{(}\PY{n}{table1}\PY{p}{,} \PY{n}{table2}\PY{p}{,} \PY{n}{hashfunction}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Parition phase }
    \PY{n}{t1Partition} \PY{o}{=} \PY{n}{partitionTable}\PY{p}{(}\PY{n}{table1}\PY{p}{,}\PY{n}{hashfunction}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}
    \PY{n}{t2Partition} \PY{o}{=} \PY{n}{partitionTable}\PY{p}{(}\PY{n}{table2}\PY{p}{,}\PY{n}{hashfunction}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Merge phase}
    \PY{n}{result} \PY{o}{=} \PY{p}{[}\PY{p}{]}
   
    \PY{c+c1}{\PYZsh{} ANSWER GOES HERE}
    \PY{k}{for} \PY{n}{key} \PY{o+ow}{in} \PY{n}{t1Partition}\PY{p}{:}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{t1Partition}\PY{p}{[}\PY{n}{key}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{t2Partition}\PY{p}{[}\PY{n}{key}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                \PY{n}{result}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{t1Partition}\PY{p}{[}\PY{n}{key}\PY{p}{]}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{t1Partition}\PY{p}{[}\PY{n}{key}\PY{p}{]}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{t2Partition}\PY{p}{[}\PY{n}{key}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} To populate your output you should use the following code(t1Entry and t2Entry are possible var names for tuples)}
    \PY{c+c1}{\PYZsh{} result.append((t1Entry.teamname, t1Entry.playername, t2Entry.collegename))}
    \PY{k}{return} \PY{n}{result}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-a.ii}{%
\subsubsection{Part (a.ii)}\label{part-a.ii}}

\textbf{\emph{{[}1 point{]}}}

It time to evaluate your algorithm! The code provided below executes the
join between teams and colleges and measures the total execution time.
What is the total number of entries output by your algorithm?

Does the runtime of your algorithm seem reasonable? Provide a brief
explanation.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{time}
\PY{n}{start\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
\PY{n}{res1} \PY{o}{=} \PY{n}{hashJoin}\PY{p}{(}\PY{n}{teams}\PY{p}{,} \PY{n}{colleges}\PY{p}{,} \PY{n}{h}\PY{p}{,} \PY{n}{buckets}\PY{p}{)}
\PY{n}{end\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
\PY{n}{duration} \PY{o}{=} \PY{p}{(}\PY{n}{end\PYZus{}time} \PY{o}{\PYZhy{}} \PY{n}{start\PYZus{}time}\PY{p}{)}\PY{o}{*}\PY{l+m+mi}{1000} \PY{c+c1}{\PYZsh{}in ms}
\PY{n+nb}{print}\PY{p}{(} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The join took }\PY{l+s+si}{\PYZpc{}0.2f}\PY{l+s+s1}{ ms and returned }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{ tuples in total}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{duration}\PY{p}{,}\PY{n+nb}{len}\PY{p}{(}\PY{n}{res1}\PY{p}{)}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} EXPLANATION GOES HERE}
\PY{c+c1}{\PYZsh{}The join took 22476.07 ms and returned 21301800 tuples in total,it seems reasonable for the size of tuples is so big }
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b}{%
\subsection{Part (b)}\label{part-b}}

You decide to investigate the performance of \texttt{hashJoin(\ )}
further. Since you implemented the merge phase of \texttt{hashJoin(\ )}
yourself you focus on the partitioning obtained by using the provided
hash function \texttt{h(\ )}. In the lectures we saw that a good hash
function should partition entries uniformly across buckets. We will now
check if \texttt{h(\ )} is indeed a good function.

The following code generates a histogram of the bucket sizes for table
teams (using the above hash function \texttt{h} and 500 buckets) to help
figure out what is going wrong.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Examine if this is a good partition function}
\PY{k}{def} \PY{n+nf}{histogramPoints}\PY{p}{(}\PY{n}{partition}\PY{p}{)}\PY{p}{:}
    \PY{n}{ids} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{n}{buckets}\PY{p}{)}
    \PY{n}{items} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{buckets}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{i} \PY{o+ow}{in} \PY{n}{partition}\PY{p}{:}
            \PY{n}{items}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{partition}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{items}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
    \PY{k}{return} \PY{n}{ids}\PY{p}{,} \PY{n}{items}

\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} Plot bucket histogram}
\PY{n}{buckets} \PY{o}{=} \PY{l+m+mi}{500}
\PY{n}{teamsPartition} \PY{o}{=} \PY{n}{partitionTable}\PY{p}{(}\PY{n}{teams}\PY{p}{,}\PY{n}{h}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}
\PY{n}{ids}\PY{p}{,} \PY{n}{counts} \PY{o}{=} \PY{n}{histogramPoints}\PY{p}{(}\PY{n}{teamsPartition}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{ids}\PY{p}{,} \PY{n}{counts}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b.i}{%
\paragraph{Part (b.i)}\label{part-b.i}}

\textbf{\emph{{[}3 points{]}}}

Now find the skew associated with the above histogram. Skew is defined
as the standard deviation of the number of entries in the buckets. A
uniform hash function produces buckets of equal size, leading to 0 skew,
but our candidate hash function h is imperfect so you should observe a
positive skew.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} ANSWER}
\PY{c+c1}{\PYZsh{} partition\PYZhy{} a table partition as returned by method partitionTable}
\PY{c+c1}{\PYZsh{} return value \PYZhy{} a float representing the skew of hash function (i.e. stdev of chefs assigned to each restaurant)}
\PY{k+kn}{import} \PY{n+nn}{math}
\PY{k}{def} \PY{n+nf}{calculateSkew}\PY{p}{(}\PY{n}{partition}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} ANSWER STARTS HERE}
    \PY{n}{skew} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n}{ids}\PY{p}{,} \PY{n}{counts} \PY{o}{=} \PY{n}{histogramPoints}\PY{p}{(}\PY{n}{partation}\PY{p}{)}
    \PY{n+nb}{sum}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{counts}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{sum}\PY{o}{+}\PY{o}{=}\PY{n}{counts}\PY{p}{[}\PY{n}{i}\PY{p}{]}
    \PY{n}{average}\PY{o}{=}\PY{n+nb}{sum}\PY{o}{/}\PY{n+nb}{len}\PY{p}{(}\PY{n}{counts}\PY{p}{)}
    \PY{n+nb}{sum}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{counts}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{sum}\PY{o}{+}\PY{o}{=}\PY{p}{(}\PY{n}{counts}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{n}{average}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}
    \PY{n}{skew}\PY{o}{=}\PY{n}{math}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n+nb}{sum}\PY{o}{/}\PY{n+nb}{len}\PY{p}{(}\PY{n}{counts}\PY{p}{)}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} ANSWER ENDS HERE}
    \PY{k}{return} \PY{n}{skew}
\PY{c+c1}{\PYZsh{}when use data of the question above ,skew is 204.83263021305766}
\PY{n+nb}{print} \PY{n}{calculateSkew}\PY{p}{(}\PY{n}{teamsPartition}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b.ii}{%
\paragraph{Part (b.ii)}\label{part-b.ii}}

\textbf{\emph{{[}1 point{]}}}

Use python's hash function to see if you can produce a better (aka
smaller) runtime for hash join. As at the beginning of part b, make a
histogram of the bucket sizes (this time using the new hash function and
500 buckets). You can plot your histogram using the same code provided
above.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Design a better hash function and print the skew difference for }
\PY{k}{def} \PY{n+nf}{hBetter}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}\PY{p}{:}
    \PY{n}{rawKey} \PY{o}{=} \PY{n+nb}{hash}\PY{p}{(}\PY{n}{x}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{k}{return} \PY{n}{rawKey} \PY{o}{\PYZpc{}} \PY{n}{buckets}

\PY{c+c1}{\PYZsh{} Plot bucket histogram}
\PY{n}{buckets} \PY{o}{=} \PY{l+m+mi}{500}
\PY{n}{teamsPartition} \PY{o}{=} \PY{n}{partitionTable}\PY{p}{(}\PY{n}{teams}\PY{p}{,}\PY{n}{hBetter}\PY{p}{,}\PY{n}{buckets}\PY{p}{)}
\PY{n}{ids}\PY{p}{,} \PY{n}{counts} \PY{o}{=} \PY{n}{histogramPoints}\PY{p}{(}\PY{n}{teamsPartition}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{ids}\PY{p}{,} \PY{n}{counts}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-b.iii}{%
\paragraph{Part (b.iii)}\label{part-b.iii}}

\textbf{\emph{{[}1 point{]}}}

Rerun your hash join algorithm with the new hash function you designed
and 500 buckets. Does the algorithm run faster? If so what is the
speed-up you are observing?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{start\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}

\PY{n}{res1} \PY{o}{=} \PY{n}{hashJoin}\PY{p}{(}\PY{n}{teams}\PY{p}{,} \PY{n}{colleges}\PY{p}{,} \PY{n}{hBetter}\PY{p}{,} \PY{n}{buckets}\PY{p}{)}

\PY{n}{end\PYZus{}time} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
\PY{n}{duration} \PY{o}{=} \PY{p}{(}\PY{n}{end\PYZus{}time} \PY{o}{\PYZhy{}} \PY{n}{start\PYZus{}time}\PY{p}{)}\PY{o}{*}\PY{l+m+mi}{1000} \PY{c+c1}{\PYZsh{}in ms}
\PY{n+nb}{print} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The join took }\PY{l+s+si}{\PYZpc{}0.2f}\PY{l+s+s1}{ ms and returned }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s1}{ tuples in total}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{duration}\PY{p}{,}\PY{n+nb}{len}\PY{p}{(}\PY{n}{res1}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} WRITE DOWN THE SPEED UP}
\PY{c+c1}{\PYZsh{}Actually there is no speed\PYZhy{}up for the join took 22890.79 ms and returned 21405000 tuples in total,the size of tuples is bigger than the }
\PY{c+c1}{\PYZsh{}original which is 21301800}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{part-c}{%
\subsection{Part (c)}\label{part-c}}

\textbf{\emph{{[}0 points{]}}}

For our internal sabermetrics purposes. Is Joe Flacco an elite
quarterback? (True for elite, False for not elite)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{flacco\PYZus{}elite} \PY{o}{=} \PY{k+kc}{True}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
